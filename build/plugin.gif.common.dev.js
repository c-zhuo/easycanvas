(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/gifler/gifler.js":
/*!***************************************!*\
  !*** ./node_modules/gifler/gifler.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var require;var require;\n\n(function e(t, n, r) {\n  function s(o, u) {\n    if (!n[o]) {\n      if (!t[o]) {\n        var a = typeof require == \"function\" && require;\n        if (!u && a) return require(o, !0);\n        if (i) return i(o, !0);\n        var f = new Error(\"Cannot find module '\" + o + \"'\");\n        throw f.code = \"MODULE_NOT_FOUND\", f;\n      }\n\n      var l = n[o] = {\n        exports: {}\n      };\n      t[o][0].call(l.exports, function (e) {\n        var n = t[o][1][e];\n        return s(n ? n : e);\n      }, l, l.exports, e, t, n, r);\n    }\n\n    return n[o].exports;\n  }\n\n  var i = typeof require == \"function\" && require;\n\n  for (var o = 0; o < r.length; o++) {\n    s(r[o]);\n  }\n\n  return s;\n})({\n  1: [function (require, module, exports) {\n    // (c) Dean McNamee <dean@gmail.com>, 2013.\n    //\n    // https://github.com/deanm/omggif\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a copy\n    // of this software and associated documentation files (the \"Software\"), to\n    // deal in the Software without restriction, including without limitation the\n    // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n    // sell copies of the Software, and to permit persons to whom the Software is\n    // furnished to do so, subject to the following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included in\n    // all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n    // IN THE SOFTWARE.\n    //\n    // omggif is a JavaScript implementation of a GIF 89a encoder and decoder,\n    // including animation and compression.  It does not rely on any specific\n    // underlying system, so should run in the browser, Node, or Plask.\n    function GifWriter(buf, width, height, gopts) {\n      var p = 0;\n      var gopts = gopts === undefined ? {} : gopts;\n      var loop_count = gopts.loop === undefined ? null : gopts.loop;\n      var global_palette = gopts.palette === undefined ? null : gopts.palette;\n      if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw \"Width/Height invalid.\";\n\n      function check_palette_and_num_colors(palette) {\n        var num_colors = palette.length;\n        if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) throw \"Invalid code/color length, must be power of 2 and 2 .. 256.\";\n        return num_colors;\n      } // - Header.\n\n\n      buf[p++] = 0x47;\n      buf[p++] = 0x49;\n      buf[p++] = 0x46; // GIF\n\n      buf[p++] = 0x38;\n      buf[p++] = 0x39;\n      buf[p++] = 0x61; // 89a\n      // Handling of Global Color Table (palette) and background index.\n\n      var gp_num_colors_pow2 = 0;\n      var background = 0;\n\n      if (global_palette !== null) {\n        var gp_num_colors = check_palette_and_num_colors(global_palette);\n\n        while (gp_num_colors >>= 1) {\n          ++gp_num_colors_pow2;\n        }\n\n        gp_num_colors = 1 << gp_num_colors_pow2;\n        --gp_num_colors_pow2;\n\n        if (gopts.background !== undefined) {\n          background = gopts.background;\n          if (background >= gp_num_colors) throw \"Background index out of range.\"; // The GIF spec states that a background index of 0 should be ignored, so\n          // this is probably a mistake and you really want to set it to another\n          // slot in the palette.  But actually in the end most browsers, etc end\n          // up ignoring this almost completely (including for dispose background).\n\n          if (background === 0) throw \"Background index explicitly passed as 0.\";\n        }\n      } // - Logical Screen Descriptor.\n      // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.\n\n\n      buf[p++] = width & 0xff;\n      buf[p++] = width >> 8 & 0xff;\n      buf[p++] = height & 0xff;\n      buf[p++] = height >> 8 & 0xff; // NOTE: Indicates 0-bpp original color resolution (unused?).\n\n      buf[p++] = (global_palette !== null ? 0x80 : 0) | // Global Color Table Flag.\n      gp_num_colors_pow2; // NOTE: No sort flag (unused?).\n\n      buf[p++] = background; // Background Color Index.\n\n      buf[p++] = 0; // Pixel aspect ratio (unused?).\n      // - Global Color Table\n\n      if (global_palette !== null) {\n        for (var i = 0, il = global_palette.length; i < il; ++i) {\n          var rgb = global_palette[i];\n          buf[p++] = rgb >> 16 & 0xff;\n          buf[p++] = rgb >> 8 & 0xff;\n          buf[p++] = rgb & 0xff;\n        }\n      }\n\n      if (loop_count !== null) {\n        // Netscape block for looping.\n        if (loop_count < 0 || loop_count > 65535) throw \"Loop count invalid.\"; // Extension code, label, and length.\n\n        buf[p++] = 0x21;\n        buf[p++] = 0xff;\n        buf[p++] = 0x0b; // NETSCAPE2.0\n\n        buf[p++] = 0x4e;\n        buf[p++] = 0x45;\n        buf[p++] = 0x54;\n        buf[p++] = 0x53;\n        buf[p++] = 0x43;\n        buf[p++] = 0x41;\n        buf[p++] = 0x50;\n        buf[p++] = 0x45;\n        buf[p++] = 0x32;\n        buf[p++] = 0x2e;\n        buf[p++] = 0x30; // Sub-block\n\n        buf[p++] = 0x03;\n        buf[p++] = 0x01;\n        buf[p++] = loop_count & 0xff;\n        buf[p++] = loop_count >> 8 & 0xff;\n        buf[p++] = 0x00; // Terminator.\n      }\n\n      var ended = false;\n\n      this.addFrame = function (x, y, w, h, indexed_pixels, opts) {\n        if (ended === true) {\n          --p;\n          ended = false;\n        } // Un-end.\n\n\n        opts = opts === undefined ? {} : opts; // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual\n        // canvas width/height, I imagine?\n\n        if (x < 0 || y < 0 || x > 65535 || y > 65535) throw \"x/y invalid.\";\n        if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw \"Width/Height invalid.\";\n        if (indexed_pixels.length < w * h) throw \"Not enough pixels for the frame size.\";\n        var using_local_palette = true;\n        var palette = opts.palette;\n\n        if (palette === undefined || palette === null) {\n          using_local_palette = false;\n          palette = global_palette;\n        }\n\n        if (palette === undefined || palette === null) throw \"Must supply either a local or global palette.\";\n        var num_colors = check_palette_and_num_colors(palette); // Compute the min_code_size (power of 2), destroying num_colors.\n\n        var min_code_size = 0;\n\n        while (num_colors >>= 1) {\n          ++min_code_size;\n        }\n\n        num_colors = 1 << min_code_size; // Now we can easily get it back.\n\n        var delay = opts.delay === undefined ? 0 : opts.delay; // From the spec:\n        //     0 -   No disposal specified. The decoder is\n        //           not required to take any action.\n        //     1 -   Do not dispose. The graphic is to be left\n        //           in place.\n        //     2 -   Restore to background color. The area used by the\n        //           graphic must be restored to the background color.\n        //     3 -   Restore to previous. The decoder is required to\n        //           restore the area overwritten by the graphic with\n        //           what was there prior to rendering the graphic.\n        //  4-7 -    To be defined.\n        // NOTE(deanm): Dispose background doesn't really work, apparently most\n        // browsers ignore the background palette index and clear to transparency.\n\n        var disposal = opts.disposal === undefined ? 0 : opts.disposal;\n        if (disposal < 0 || disposal > 3) // 4-7 is reserved.\n          throw \"Disposal out of range.\";\n        var use_transparency = false;\n        var transparent_index = 0;\n\n        if (opts.transparent !== undefined && opts.transparent !== null) {\n          use_transparency = true;\n          transparent_index = opts.transparent;\n          if (transparent_index < 0 || transparent_index >= num_colors) throw \"Transparent color index.\";\n        }\n\n        if (disposal !== 0 || use_transparency || delay !== 0) {\n          // - Graphics Control Extension\n          buf[p++] = 0x21;\n          buf[p++] = 0xf9; // Extension / Label.\n\n          buf[p++] = 4; // Byte size.\n\n          buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);\n          buf[p++] = delay & 0xff;\n          buf[p++] = delay >> 8 & 0xff;\n          buf[p++] = transparent_index; // Transparent color index.\n\n          buf[p++] = 0; // Block Terminator.\n        } // - Image Descriptor\n\n\n        buf[p++] = 0x2c; // Image Seperator.\n\n        buf[p++] = x & 0xff;\n        buf[p++] = x >> 8 & 0xff; // Left.\n\n        buf[p++] = y & 0xff;\n        buf[p++] = y >> 8 & 0xff; // Top.\n\n        buf[p++] = w & 0xff;\n        buf[p++] = w >> 8 & 0xff;\n        buf[p++] = h & 0xff;\n        buf[p++] = h >> 8 & 0xff; // NOTE: No sort flag (unused?).\n        // TODO(deanm): Support interlace.\n\n        buf[p++] = using_local_palette === true ? 0x80 | min_code_size - 1 : 0; // - Local Color Table\n\n        if (using_local_palette === true) {\n          for (var i = 0, il = palette.length; i < il; ++i) {\n            var rgb = palette[i];\n            buf[p++] = rgb >> 16 & 0xff;\n            buf[p++] = rgb >> 8 & 0xff;\n            buf[p++] = rgb & 0xff;\n          }\n        }\n\n        p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);\n      };\n\n      this.end = function () {\n        if (ended === false) {\n          buf[p++] = 0x3b; // Trailer.\n\n          ended = true;\n        }\n\n        return p;\n      };\n    } // Main compression routine, palette indexes -> LZW code stream.\n    // |index_stream| must have at least one entry.\n\n\n    function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {\n      buf[p++] = min_code_size;\n      var cur_subblock = p++; // Pointing at the length field.\n\n      var clear_code = 1 << min_code_size;\n      var code_mask = clear_code - 1;\n      var eoi_code = clear_code + 1;\n      var next_code = eoi_code + 1;\n      var cur_code_size = min_code_size + 1; // Number of bits per code.\n\n      var cur_shift = 0; // We have at most 12-bit codes, so we should have to hold a max of 19\n      // bits here (and then we would write out).\n\n      var cur = 0;\n\n      function emit_bytes_to_buffer(bit_block_size) {\n        while (cur_shift >= bit_block_size) {\n          buf[p++] = cur & 0xff;\n          cur >>= 8;\n          cur_shift -= 8;\n\n          if (p === cur_subblock + 256) {\n            // Finished a subblock.\n            buf[cur_subblock] = 255;\n            cur_subblock = p++;\n          }\n        }\n      }\n\n      function emit_code(c) {\n        cur |= c << cur_shift;\n        cur_shift += cur_code_size;\n        emit_bytes_to_buffer(8);\n      } // I am not an expert on the topic, and I don't want to write a thesis.\n      // However, it is good to outline here the basic algorithm and the few data\n      // structures and optimizations here that make this implementation fast.\n      // The basic idea behind LZW is to build a table of previously seen runs\n      // addressed by a short id (herein called output code).  All data is\n      // referenced by a code, which represents one or more values from the\n      // original input stream.  All input bytes can be referenced as the same\n      // value as an output code.  So if you didn't want any compression, you\n      // could more or less just output the original bytes as codes (there are\n      // some details to this, but it is the idea).  In order to achieve\n      // compression, values greater then the input range (codes can be up to\n      // 12-bit while input only 8-bit) represent a sequence of previously seen\n      // inputs.  The decompressor is able to build the same mapping while\n      // decoding, so there is always a shared common knowledge between the\n      // encoding and decoder, which is also important for \"timing\" aspects like\n      // how to handle variable bit width code encoding.\n      //\n      // One obvious but very important consequence of the table system is there\n      // is always a unique id (at most 12-bits) to map the runs.  'A' might be\n      // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship\n      // can be used for an effecient lookup strategy for the code mapping.  We\n      // need to know if a run has been seen before, and be able to map that run\n      // to the output code.  Since we start with known unique ids (input bytes),\n      // and then from those build more unique ids (table entries), we can\n      // continue this chain (almost like a linked list) to always have small\n      // integer values that represent the current byte chains in the encoder.\n      // This means instead of tracking the input bytes (AAAABCD) to know our\n      // current state, we can track the table entry for AAAABC (it is guaranteed\n      // to exist by the nature of the algorithm) and the next character D.\n      // Therefor the tuple of (table_entry, byte) is guaranteed to also be\n      // unique.  This allows us to create a simple lookup key for mapping input\n      // sequences to codes (table indices) without having to store or search\n      // any of the code sequences.  So if 'AAAA' has a table entry of 12, the\n      // tuple of ('AAAA', K) for any input byte K will be unique, and can be our\n      // key.  This leads to a integer value at most 20-bits, which can always\n      // fit in an SMI value and be used as a fast sparse array / object key.\n      // Output code for the current contents of the index buffer.\n\n\n      var ib_code = index_stream[0] & code_mask; // Load first input index.\n\n      var code_table = {}; // Key'd on our 20-bit \"tuple\".\n\n      emit_code(clear_code); // Spec says first code should be a clear code.\n      // First index already loaded, process the rest of the stream.\n\n      for (var i = 1, il = index_stream.length; i < il; ++i) {\n        var k = index_stream[i] & code_mask;\n        var cur_key = ib_code << 8 | k; // (prev, k) unique tuple.\n\n        var cur_code = code_table[cur_key]; // buffer + k.\n        // Check if we have to create a new code table entry.\n\n        if (cur_code === undefined) {\n          // We don't have buffer + k.\n          // Emit index buffer (without k).\n          // This is an inline version of emit_code, because this is the core\n          // writing routine of the compressor (and V8 cannot inline emit_code\n          // because it is a closure here in a different context).  Additionally\n          // we can call emit_byte_to_buffer less often, because we can have\n          // 30-bits (from our 31-bit signed SMI), and we know our codes will only\n          // be 12-bits, so can safely have 18-bits there without overflow.\n          // emit_code(ib_code);\n          cur |= ib_code << cur_shift;\n          cur_shift += cur_code_size;\n\n          while (cur_shift >= 8) {\n            buf[p++] = cur & 0xff;\n            cur >>= 8;\n            cur_shift -= 8;\n\n            if (p === cur_subblock + 256) {\n              // Finished a subblock.\n              buf[cur_subblock] = 255;\n              cur_subblock = p++;\n            }\n          }\n\n          if (next_code === 4096) {\n            // Table full, need a clear.\n            emit_code(clear_code);\n            next_code = eoi_code + 1;\n            cur_code_size = min_code_size + 1;\n            code_table = {};\n          } else {\n            // Table not full, insert a new entry.\n            // Increase our variable bit code sizes if necessary.  This is a bit\n            // tricky as it is based on \"timing\" between the encoding and\n            // decoder.  From the encoders perspective this should happen after\n            // we've already emitted the index buffer and are about to create the\n            // first table entry that would overflow our current code bit size.\n            if (next_code >= 1 << cur_code_size) ++cur_code_size;\n            code_table[cur_key] = next_code++; // Insert into code table.\n          }\n\n          ib_code = k; // Index buffer to single input k.\n        } else {\n          ib_code = cur_code; // Index buffer to sequence in code table.\n        }\n      }\n\n      emit_code(ib_code); // There will still be something in the index buffer.\n\n      emit_code(eoi_code); // End Of Information.\n      // Flush / finalize the sub-blocks stream to the buffer.\n\n      emit_bytes_to_buffer(1); // Finish the sub-blocks, writing out any unfinished lengths and\n      // terminating with a sub-block of length 0.  If we have already started\n      // but not yet used a sub-block it can just become the terminator.\n\n      if (cur_subblock + 1 === p) {\n        // Started but unused.\n        buf[cur_subblock] = 0;\n      } else {\n        // Started and used, write length and additional terminator block.\n        buf[cur_subblock] = p - cur_subblock - 1;\n        buf[p++] = 0;\n      }\n\n      return p;\n    }\n\n    function GifReader(buf) {\n      var p = 0; // - Header (GIF87a or GIF89a).\n\n      if (buf[p++] !== 0x47 || buf[p++] !== 0x49 || buf[p++] !== 0x46 || buf[p++] !== 0x38 || (buf[p++] + 1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {\n        throw \"Invalid GIF 87a/89a header.\";\n      } // - Logical Screen Descriptor.\n\n\n      var width = buf[p++] | buf[p++] << 8;\n      var height = buf[p++] | buf[p++] << 8;\n      var pf0 = buf[p++]; // <Packed Fields>.\n\n      var global_palette_flag = pf0 >> 7;\n      var num_global_colors_pow2 = pf0 & 0x7;\n      var num_global_colors = 1 << num_global_colors_pow2 + 1;\n      var background = buf[p++];\n      buf[p++]; // Pixel aspect ratio (unused?).\n\n      var global_palette_offset = null;\n\n      if (global_palette_flag) {\n        global_palette_offset = p;\n        p += num_global_colors * 3; // Seek past palette.\n      }\n\n      var no_eof = true;\n      var frames = [];\n      var delay = 0;\n      var transparent_index = null;\n      var disposal = 0; // 0 - No disposal specified.\n\n      var loop_count = null;\n      this.width = width;\n      this.height = height;\n\n      while (no_eof && p < buf.length) {\n        switch (buf[p++]) {\n          case 0x21:\n            // Graphics Control Extension Block\n            switch (buf[p++]) {\n              case 0xff:\n                // Application specific block\n                // Try if it's a Netscape block (with animation loop counter).\n                if (buf[p] !== 0x0b || // 21 FF already read, check block size.\n                // NETSCAPE2.0\n                buf[p + 1] == 0x4e && buf[p + 2] == 0x45 && buf[p + 3] == 0x54 && buf[p + 4] == 0x53 && buf[p + 5] == 0x43 && buf[p + 6] == 0x41 && buf[p + 7] == 0x50 && buf[p + 8] == 0x45 && buf[p + 9] == 0x32 && buf[p + 10] == 0x2e && buf[p + 11] == 0x30 && // Sub-block\n                buf[p + 12] == 0x03 && buf[p + 13] == 0x01 && buf[p + 16] == 0) {\n                  p += 14;\n                  loop_count = buf[p++] | buf[p++] << 8;\n                  p++; // Skip terminator.\n                } else {\n                  // We don't know what it is, just try to get past it.\n                  p += 12;\n\n                  while (true) {\n                    // Seek through subblocks.\n                    var block_size = buf[p++];\n                    if (block_size === 0) break;\n                    p += block_size;\n                  }\n                }\n\n                break;\n\n              case 0xf9:\n                // Graphics Control Extension\n                if (buf[p++] !== 0x4 || buf[p + 4] !== 0) throw \"Invalid graphics extension block.\";\n                var pf1 = buf[p++];\n                delay = buf[p++] | buf[p++] << 8;\n                transparent_index = buf[p++];\n                if ((pf1 & 1) === 0) transparent_index = null;\n                disposal = pf1 >> 2 & 0x7;\n                p++; // Skip terminator.\n\n                break;\n\n              case 0xfe:\n                // Comment Extension.\n                while (true) {\n                  // Seek through subblocks.\n                  var block_size = buf[p++];\n                  if (block_size === 0) break; // console.log(buf.slice(p, p+block_size).toString('ascii'));\n\n                  p += block_size;\n                }\n\n                break;\n\n              default:\n                throw \"Unknown graphic control label: 0x\" + buf[p - 1].toString(16);\n            }\n\n            break;\n\n          case 0x2c:\n            // Image Descriptor.\n            var x = buf[p++] | buf[p++] << 8;\n            var y = buf[p++] | buf[p++] << 8;\n            var w = buf[p++] | buf[p++] << 8;\n            var h = buf[p++] | buf[p++] << 8;\n            var pf2 = buf[p++];\n            var local_palette_flag = pf2 >> 7;\n            var interlace_flag = pf2 >> 6 & 1;\n            var num_local_colors_pow2 = pf2 & 0x7;\n            var num_local_colors = 1 << num_local_colors_pow2 + 1;\n            var palette_offset = global_palette_offset;\n            var has_local_palette = false;\n\n            if (local_palette_flag) {\n              var has_local_palette = true;\n              palette_offset = p; // Override with local palette.\n\n              p += num_local_colors * 3; // Seek past palette.\n            }\n\n            var data_offset = p;\n            p++; // codesize\n\n            while (true) {\n              var block_size = buf[p++];\n              if (block_size === 0) break;\n              p += block_size;\n            }\n\n            frames.push({\n              x: x,\n              y: y,\n              width: w,\n              height: h,\n              has_local_palette: has_local_palette,\n              palette_offset: palette_offset,\n              data_offset: data_offset,\n              data_length: p - data_offset,\n              transparent_index: transparent_index,\n              interlaced: !!interlace_flag,\n              delay: delay,\n              disposal: disposal\n            });\n            break;\n\n          case 0x3b:\n            // Trailer Marker (end of file).\n            no_eof = false;\n            break;\n\n          default:\n            throw \"Unknown gif block: 0x\" + buf[p - 1].toString(16);\n            break;\n        }\n      }\n\n      this.numFrames = function () {\n        return frames.length;\n      };\n\n      this.loopCount = function () {\n        return loop_count;\n      };\n\n      this.frameInfo = function (frame_num) {\n        if (frame_num < 0 || frame_num >= frames.length) throw \"Frame index out of range.\";\n        return frames[frame_num];\n      };\n\n      this.decodeAndBlitFrameBGRA = function (frame_num, pixels) {\n        var frame = this.frameInfo(frame_num);\n        var num_pixels = frame.width * frame.height;\n        var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.\n\n        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);\n        var palette_offset = frame.palette_offset; // NOTE(deanm): It seems to be much faster to compare index to 256 than\n        // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n        // the profile, not sure if it's related to using a Uint8Array.\n\n        var trans = frame.transparent_index;\n        if (trans === null) trans = 256; // We are possibly just blitting to a portion of the entire frame.\n        // That is a subrect within the framerect, so the additional pixels\n        // must be skipped over after we finished a scanline.\n\n        var framewidth = frame.width;\n        var framestride = width - framewidth;\n        var xleft = framewidth; // Number of subrect pixels left in scanline.\n        // Output indicies of the top left and bottom right corners of the subrect.\n\n        var opbeg = (frame.y * width + frame.x) * 4;\n        var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n        var op = opbeg;\n        var scanstride = framestride * 4; // Use scanstride to skip past the rows when interlacing.  This is skipping\n        // 7 rows for the first two passes, then 3 then 1.\n\n        if (frame.interlaced === true) {\n          scanstride += width * 4 * 7; // Pass 1.\n        }\n\n        var interlaceskip = 8; // Tracking the row interval in the current pass.\n\n        for (var i = 0, il = index_stream.length; i < il; ++i) {\n          var index = index_stream[i];\n\n          if (xleft === 0) {\n            // Beginning of new scan line\n            op += scanstride;\n            xleft = framewidth;\n\n            if (op >= opend) {\n              // Catch the wrap to switch passes when interlacing.\n              scanstride = framestride * 4 + width * 4 * (interlaceskip - 1); // interlaceskip / 2 * 4 is interlaceskip << 1.\n\n              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n              interlaceskip >>= 1;\n            }\n          }\n\n          if (index === trans) {\n            op += 4;\n          } else {\n            var r = buf[palette_offset + index * 3];\n            var g = buf[palette_offset + index * 3 + 1];\n            var b = buf[palette_offset + index * 3 + 2];\n            pixels[op++] = b;\n            pixels[op++] = g;\n            pixels[op++] = r;\n            pixels[op++] = 255;\n          }\n\n          --xleft;\n        }\n      }; // I will go to copy and paste hell one day...\n\n\n      this.decodeAndBlitFrameRGBA = function (frame_num, pixels) {\n        var frame = this.frameInfo(frame_num);\n        var num_pixels = frame.width * frame.height;\n        var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.\n\n        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);\n        var palette_offset = frame.palette_offset; // NOTE(deanm): It seems to be much faster to compare index to 256 than\n        // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n        // the profile, not sure if it's related to using a Uint8Array.\n\n        var trans = frame.transparent_index;\n        if (trans === null) trans = 256; // We are possibly just blitting to a portion of the entire frame.\n        // That is a subrect within the framerect, so the additional pixels\n        // must be skipped over after we finished a scanline.\n\n        var framewidth = frame.width;\n        var framestride = width - framewidth;\n        var xleft = framewidth; // Number of subrect pixels left in scanline.\n        // Output indicies of the top left and bottom right corners of the subrect.\n\n        var opbeg = (frame.y * width + frame.x) * 4;\n        var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n        var op = opbeg;\n        var scanstride = framestride * 4; // Use scanstride to skip past the rows when interlacing.  This is skipping\n        // 7 rows for the first two passes, then 3 then 1.\n\n        if (frame.interlaced === true) {\n          scanstride += width * 4 * 7; // Pass 1.\n        }\n\n        var interlaceskip = 8; // Tracking the row interval in the current pass.\n\n        for (var i = 0, il = index_stream.length; i < il; ++i) {\n          var index = index_stream[i];\n\n          if (xleft === 0) {\n            // Beginning of new scan line\n            op += scanstride;\n            xleft = framewidth;\n\n            if (op >= opend) {\n              // Catch the wrap to switch passes when interlacing.\n              scanstride = framestride * 4 + width * 4 * (interlaceskip - 1); // interlaceskip / 2 * 4 is interlaceskip << 1.\n\n              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n              interlaceskip >>= 1;\n            }\n          }\n\n          if (index === trans) {\n            op += 4;\n          } else {\n            var r = buf[palette_offset + index * 3];\n            var g = buf[palette_offset + index * 3 + 1];\n            var b = buf[palette_offset + index * 3 + 2];\n            pixels[op++] = r;\n            pixels[op++] = g;\n            pixels[op++] = b;\n            pixels[op++] = 255;\n          }\n\n          --xleft;\n        }\n      };\n    }\n\n    function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {\n      var min_code_size = code_stream[p++];\n      var clear_code = 1 << min_code_size;\n      var eoi_code = clear_code + 1;\n      var next_code = eoi_code + 1;\n      var cur_code_size = min_code_size + 1; // Number of bits per code.\n      // NOTE: This shares the same name as the encoder, but has a different\n      // meaning here.  Here this masks each code coming from the code stream.\n\n      var code_mask = (1 << cur_code_size) - 1;\n      var cur_shift = 0;\n      var cur = 0;\n      var op = 0; // Output pointer.\n\n      var subblock_size = code_stream[p++]; // TODO(deanm): Would using a TypedArray be any faster?  At least it would\n      // solve the fast mode / backing store uncertainty.\n      // var code_table = Array(4096);\n\n      var code_table = new Int32Array(4096); // Can be signed, we only use 20 bits.\n\n      var prev_code = null; // Track code-1.\n\n      while (true) {\n        // Read up to two bytes, making sure we always 12-bits for max sized code.\n        while (cur_shift < 16) {\n          if (subblock_size === 0) break; // No more data to be read.\n\n          cur |= code_stream[p++] << cur_shift;\n          cur_shift += 8;\n\n          if (subblock_size === 1) {\n            // Never let it get to 0 to hold logic above.\n            subblock_size = code_stream[p++]; // Next subblock.\n          } else {\n            --subblock_size;\n          }\n        } // TODO(deanm): We should never really get here, we should have received\n        // and EOI.\n\n\n        if (cur_shift < cur_code_size) break;\n        var code = cur & code_mask;\n        cur >>= cur_code_size;\n        cur_shift -= cur_code_size; // TODO(deanm): Maybe should check that the first code was a clear code,\n        // at least this is what you're supposed to do.  But actually our encoder\n        // now doesn't emit a clear code first anyway.\n\n        if (code === clear_code) {\n          // We don't actually have to clear the table.  This could be a good idea\n          // for greater error checking, but we don't really do any anyway.  We\n          // will just track it with next_code and overwrite old entries.\n          next_code = eoi_code + 1;\n          cur_code_size = min_code_size + 1;\n          code_mask = (1 << cur_code_size) - 1; // Don't update prev_code ?\n\n          prev_code = null;\n          continue;\n        } else if (code === eoi_code) {\n          break;\n        } // We have a similar situation as the decoder, where we want to store\n        // variable length entries (code table entries), but we want to do in a\n        // faster manner than an array of arrays.  The code below stores sort of a\n        // linked list within the code table, and then \"chases\" through it to\n        // construct the dictionary entries.  When a new entry is created, just the\n        // last byte is stored, and the rest (prefix) of the entry is only\n        // referenced by its table entry.  Then the code chases through the\n        // prefixes until it reaches a single byte code.  We have to chase twice,\n        // first to compute the length, and then to actually copy the data to the\n        // output (backwards, since we know the length).  The alternative would be\n        // storing something in an intermediate stack, but that doesn't make any\n        // more sense.  I implemented an approach where it also stored the length\n        // in the code table, although it's a bit tricky because you run out of\n        // bits (12 + 12 + 8), but I didn't measure much improvements (the table\n        // entries are generally not the long).  Even when I created benchmarks for\n        // very long table entries the complexity did not seem worth it.\n        // The code table stores the prefix entry in 12 bits and then the suffix\n        // byte in 8 bits, so each entry is 20 bits.\n\n\n        var chase_code = code < next_code ? code : prev_code; // Chase what we will output, either {CODE} or {CODE-1}.\n\n        var chase_length = 0;\n        var chase = chase_code;\n\n        while (chase > clear_code) {\n          chase = code_table[chase] >> 8;\n          ++chase_length;\n        }\n\n        var k = chase;\n        var op_end = op + chase_length + (chase_code !== code ? 1 : 0);\n\n        if (op_end > output_length) {\n          console.log(\"Warning, gif stream longer than expected.\");\n          return;\n        } // Already have the first byte from the chase, might as well write it fast.\n\n\n        output[op++] = k;\n        op += chase_length;\n        var b = op; // Track pointer, writing backwards.\n\n        if (chase_code !== code) // The case of emitting {CODE-1} + k.\n          output[op++] = k;\n        chase = chase_code;\n\n        while (chase_length--) {\n          chase = code_table[chase];\n          output[--b] = chase & 0xff; // Write backwards.\n\n          chase >>= 8; // Pull down to the prefix code.\n        }\n\n        if (prev_code !== null && next_code < 4096) {\n          code_table[next_code++] = prev_code << 8 | k; // TODO(deanm): Figure out this clearing vs code growth logic better.  I\n          // have an feeling that it should just happen somewhere else, for now it\n          // is awkward between when we grow past the max and then hit a clear code.\n          // For now just check if we hit the max 12-bits (then a clear code should\n          // follow, also of course encoded in 12-bits).\n\n          if (next_code >= code_mask + 1 && cur_code_size < 12) {\n            ++cur_code_size;\n            code_mask = code_mask << 1 | 1;\n          }\n        }\n\n        prev_code = code;\n      }\n\n      if (op !== output_length) {\n        console.log(\"Warning, gif stream shorter than expected.\");\n      }\n\n      return output;\n    }\n\n    try {\n      exports.GifWriter = GifWriter;\n      exports.GifReader = GifReader;\n    } catch (e) {} // CommonJS.\n\n  }, {}],\n  2: [function (require, module, exports) {\n    var Animator,\n        GifReader,\n        createBufferCanvas,\n        decodeFrames,\n        getCanvasElement,\n        gifler,\n        wrapXhrCallback,\n        bind = function bind(fn, me) {\n      return function () {\n        return fn.apply(me, arguments);\n      };\n    };\n\n    GifReader = require('omggif').GifReader;\n    /*\n    Load and animate the gif.\n    \n    Arguments:\n      url      - The URL of the gif to be loaded with an XMLHttpRequest.\n      callback - Predicate argument than can be any one of the following:\n                  - function - called with a new instance of Animator\n                  - string - a query selector for a canvas element\n                  - canvas - a canvas element\n     */\n\n    gifler = function gifler(url) {\n      var aync, xhr;\n      xhr = new XMLHttpRequest();\n      xhr.open('GET', url, aync = true);\n      xhr.responseType = 'arraybuffer';\n      return {\n        xhr: xhr,\n        get: function get(callback) {\n          xhr.onload = wrapXhrCallback(callback);\n          xhr.send();\n          return this;\n        },\n        animate: function animate(selector) {\n          var canvas;\n          canvas = getCanvasElement(selector);\n          xhr.onload = wrapXhrCallback(function (animator) {\n            return animator.animateInCanvas(canvas);\n          });\n          xhr.send();\n          return this;\n        },\n        frames: function frames(selector, onDrawFrame, setCanvasDimesions) {\n          var canvas;\n\n          if (setCanvasDimesions == null) {\n            setCanvasDimesions = false;\n          }\n\n          canvas = getCanvasElement(selector);\n          xhr.onload = wrapXhrCallback(function (animator) {\n            animator.onDrawFrame = onDrawFrame;\n            return animator.animateInCanvas(canvas, setCanvasDimesions);\n          });\n          xhr.send();\n          return this;\n        }\n      };\n    };\n\n    wrapXhrCallback = function wrapXhrCallback(callback) {\n      return function (e) {\n        return callback(new Animator(new GifReader(new Uint8Array(this.response))));\n      };\n    };\n\n    getCanvasElement = function getCanvasElement(selector) {\n      var element, ref;\n\n      if (typeof selector === 'string' && ((ref = element = document.querySelector(selector)) != null ? ref.tagName : void 0) === 'CANVAS') {\n        return element;\n      } else if ((selector != null ? selector.tagName : void 0) === 'CANVAS') {\n        return selector;\n      } else {\n        throw new Error('Unexpected selector type. Valid types are query-selector-string/canvas-element');\n      }\n    };\n    /*\n    Creates a buffer canvas element since it is much faster to putImage than\n    putImageData.\n    \n    The omggif library decodes the pixels into the full gif dimensions. We only\n    need to store the frame dimensions, so we offset the putImageData call.\n     */\n\n\n    createBufferCanvas = function createBufferCanvas(frame, width, height) {\n      var bufferCanvas, bufferContext, imageData;\n      bufferCanvas = document.createElement('canvas');\n      bufferContext = bufferCanvas.getContext('2d');\n      bufferCanvas.width = frame.width;\n      bufferCanvas.height = frame.height;\n      imageData = bufferContext.createImageData(width, height);\n      imageData.data.set(frame.pixels);\n      bufferContext.putImageData(imageData, -frame.x, -frame.y);\n      return bufferCanvas;\n    };\n    /*\n    Decodes the pixels for each frame (decompressing and de-interlacing) into a\n    Uint8ClampedArray, which is suitable for canvas ImageData.\n     */\n\n\n    decodeFrames = function decodeFrames(reader, frameIndex) {\n      var j, ref, results;\n      return function () {\n        results = [];\n\n        for (var j = 0, ref = reader.numFrames(); 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {\n          results.push(j);\n        }\n\n        return results;\n      }.apply(this).map(function (_this) {\n        return function (frameIndex) {\n          var frameInfo;\n          frameInfo = reader.frameInfo(frameIndex);\n          frameInfo.pixels = new Uint8ClampedArray(reader.width * reader.height * 4);\n          reader.decodeAndBlitFrameRGBA(frameIndex, frameInfo.pixels);\n          return frameInfo;\n        };\n      }(this));\n    };\n\n    Animator = function () {\n      function Animator(_reader) {\n        var ref;\n        this._reader = _reader;\n        this._advanceFrame = bind(this._advanceFrame, this);\n        this._nextFrameRender = bind(this._nextFrameRender, this);\n        this._nextFrame = bind(this._nextFrame, this);\n        ref = this._reader, this.width = ref.width, this.height = ref.height;\n        this._frames = decodeFrames(this._reader);\n        this._loopCount = this._reader.loopCount();\n        this._loops = 0;\n        this._frameIndex = 0;\n        this._running = false;\n      }\n\n      Animator.prototype.start = function () {\n        this._lastTime = new Date().valueOf();\n        this._delayCompensation = 0;\n        this._running = true;\n        setTimeout(this._nextFrame, 0);\n        return this;\n      };\n\n      Animator.prototype.stop = function () {\n        this._running = false;\n        return this;\n      };\n\n      Animator.prototype.reset = function () {\n        this._frameIndex = 0;\n        this._loops = 0;\n        return this;\n      };\n\n      Animator.prototype._nextFrame = function () {\n        requestAnimationFrame(this._nextFrameRender);\n      };\n\n      Animator.prototype._nextFrameRender = function () {\n        var frame, ref;\n\n        if (!this._running) {\n          return;\n        }\n\n        frame = this._frames[this._frameIndex];\n\n        if ((ref = this.onFrame) != null) {\n          ref.apply(this, [frame, this._frameIndex]);\n        }\n\n        return this._enqueueNextFrame();\n      };\n\n      Animator.prototype._advanceFrame = function () {\n        this._frameIndex += 1;\n\n        if (this._frameIndex >= this._frames.length) {\n          if (this._loopCount !== 0 && this._loopCount === this._loops) {\n            this.stop();\n          } else {\n            this._frameIndex = 0;\n            this._loops += 1;\n          }\n        }\n      };\n\n      Animator.prototype._enqueueNextFrame = function () {\n        var actualDelay, delta, frame, frameDelay;\n\n        this._advanceFrame();\n\n        while (this._running) {\n          frame = this._frames[this._frameIndex];\n          delta = new Date().valueOf() - this._lastTime;\n          this._lastTime += delta;\n          this._delayCompensation += delta;\n          frameDelay = frame.delay * 10;\n          actualDelay = frameDelay - this._delayCompensation;\n          this._delayCompensation -= frameDelay;\n\n          if (actualDelay < 0) {\n            this._advanceFrame();\n\n            continue;\n          } else {\n            setTimeout(this._nextFrame, actualDelay);\n            break;\n          }\n        }\n      };\n\n      Animator.prototype.animateInCanvas = function (canvas, setDimension) {\n        var ctx;\n\n        if (setDimension == null) {\n          setDimension = true;\n        }\n\n        if (setDimension) {\n          canvas.width = this.width;\n          canvas.height = this.height;\n        }\n\n        ctx = canvas.getContext('2d');\n\n        if (this.onDrawFrame == null) {\n          this.onDrawFrame = function (ctx, frame, i) {\n            return ctx.drawImage(frame.buffer, frame.x, frame.y);\n          };\n        }\n\n        if (this.onFrame == null) {\n          this.onFrame = function (_this) {\n            return function (frame, i) {\n              var ref, saved;\n\n              if (frame.buffer == null) {\n                frame.buffer = createBufferCanvas(frame, _this.width, _this.height);\n              }\n\n              if (typeof _this.disposeFrame === \"function\") {\n                _this.disposeFrame();\n              }\n\n              switch (frame.disposal) {\n                case 2:\n                  _this.disposeFrame = function () {\n                    return ctx.clearRect(0, 0, canvas.width, canvas.height);\n                  };\n\n                  break;\n\n                case 3:\n                  saved = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n                  _this.disposeFrame = function () {\n                    return ctx.putImageData(saved, 0, 0);\n                  };\n\n                  break;\n\n                default:\n                  _this.disposeFrame = null;\n              }\n\n              return (ref = _this.onDrawFrame) != null ? ref.apply(_this, [ctx, frame, i]) : void 0;\n            };\n          }(this);\n        }\n\n        this.start();\n        return this;\n      };\n\n      return Animator;\n    }();\n\n    gifler.Animator = Animator;\n    gifler.decodeFrames = decodeFrames;\n    gifler.createBufferCanvas = createBufferCanvas;\n\n    if (typeof window !== \"undefined\" && window !== null) {\n      window.gifler = gifler;\n    }\n\n    if (typeof module !== \"undefined\" && module !== null) {\n      module.exports = gifler;\n    }\n  }, {\n    \"omggif\": 1\n  }]\n}, {}, [2]);\n\n//# sourceURL=webpack:///./node_modules/gifler/gifler.js?");

/***/ }),

/***/ "./src/plugin.gif.js":
/*!***************************!*\
  !*** ./src/plugin.gif.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = _default;\n\nvar _gifler = _interopRequireDefault(__webpack_require__(/*! gifler */ \"./node_modules/gifler/gifler.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/** ********** *\n *\n * Load gif and change to an active canvas object\n * - The canvas is in animating.\n * - 84kb larger.\n *\n * ********** **/\nvar Cache = {};\nvar ProcessingFlag = 'processing';\n\nvar _ec;\n\nvar gif2canvas = function gif2canvas(url, callback) {\n  var flag = JSON.stringify({\n    url: url // width: _width,\n    // height: _height,\n\n  });\n\n  if (Cache[flag] && Cache[flag] !== ProcessingFlag) {\n    callback(Cache[flag]);\n    return;\n  }\n\n  if (Cache[flag] === ProcessingFlag) {\n    // 防止并发初始化gif2canvas\n    setTimeout(function () {\n      gif2canvas(url, callback);\n    }, 100);\n    return;\n  }\n\n  Cache[flag] = ProcessingFlag;\n\n  _ec.ImgLoader(url, function (img) {\n    var temp = document.createElement('canvas');\n    temp.width = img.width;\n    temp.height = img.height; // Here can modify the image\n    // window.gifler(img.src).frames(temp, function (ctx, frame) {\n    //     ctx.canvas.width  = img.width;\n    //     ctx.canvas.height = img.height;\n    //     // ctx.globalCompositeOperation = 'source-over';\n    //     // ctx.fillRect(0, 0, 1100, 1100);\n    //     ctx.translate(ctx.canvas.width, 0);\n    //     ctx.scale(-1, 1);\n    //     ctx.drawImage(frame.buffer, frame.x, frame.y, frame.width, frame.height);\n    //     // Composite a color\n    //     // let hue = (frames * 10) % 360;\n    //     // ctx.globalCompositeOperation = 'source-atop';\n    //     // ctx.fillStyle = 'hsla(' + hue + ', 100%, 50%, 0.5)';\n    // }).done(function () {\n\n    window.gifler(img.src).animate(temp).done(function () {\n      Cache[flag] = temp;\n      callback(temp);\n    });\n  });\n};\n\nif (window && window.Easycanvas) {\n  _ec = window.Easycanvas;\n  _ec.gif2canvas = gif2canvas;\n}\n\nfunction _default(ec) {\n  _ec = ec;\n  ec.gif2canvas = gif2canvas;\n}\n\n;\n\n//# sourceURL=webpack:///./src/plugin.gif.js?");

/***/ }),

/***/ 2:
/*!*********************************!*\
  !*** multi ./src/plugin.gif.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/plugin.gif.js */\"./src/plugin.gif.js\");\n\n\n//# sourceURL=webpack:///multi_./src/plugin.gif.js?");

/***/ })

/******/ })));